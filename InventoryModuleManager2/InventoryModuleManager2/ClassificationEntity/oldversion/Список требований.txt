Новый список требований для этих классов:
- разбирать выражение записи класса на части по абстракции и агрегации.
- разбирать несколько записей классов, разделенных ;
- дать последний класс иерархии в кратком имени
- дать последний класс иерархии в полном виде (с родительскими классами и агрегированными классами)
- проверить, что класс является подклассом указанного класса-аргумента
- проверить, что класс является надклассом указанного класса-аргумента 
- проверить, что класс совпадает с указанным классом-аргументом.
- проверить, что запись класса не содержит нарушений структуры (имеет правильный формат)
- дать любой из классов в полном виде (собрать цепочку родительских классов из массива имен классов)
- ...

Тут для этого нужен массив или список классов. С ним и работать. А сейчас там словарь.
Класс EntityType должен представлять запись типа, состоящую из цепочки классов. И предоставлять средства для работы с ними.
Это нужно для представления типа Сущности Хранилища в объекте Сущности. 

Класс EntityTypesCollection должен представлять список или массив объектов EntityType. И использоваться для построения дерева классов.
Подобного тому что уже есть в приложении поиска, но более детального и не в TreeView.

Класс Place тут как узкий пример использования этих двух классов. Лучше чем ничего.

------------------------
Проект SpeakInterface не использует классы толком - они используются для описания типа мест. А сами места впихиваются частично в аргументы и передаются исполняющей функции. Вот она и должна поверять эти типы мест. Но пока это не применяется, так как система еще не сложилась.

----------------------------
Надо лучше проработать эту систему обозначения.
- Надо больше примеров. 
- Надо опыт использования.

Операторы < > = можно ли использовать в иерархии? 
- только внутри одной ветви классов. Соседняя ветвь уже не может так сравниваться.

-------------------------------------
Сейчас это очень сырой и непродуманный концепт.
Код написан только для класса и суперкласса или только для класса.
Более длинную ветвь нельзя указать.
Агрегированные классы могут указываться только для последнего класса.
Все отклонения от этого формата приводят к невозможности распарсить выражение.
Формат выражения не проверяется.
Код написан исходя из того что у каждого класса может быть несколько суперклассов.
И вот они-то и записаны в словарь суперклассов. Обычно он содержит ноль или один элемент - родительский класс, если он указан в записи.
И эта штука предполагает что где-то есть общее дерево классов, из которого все эти классы можно найти по их уникальному имени.
Так вот это такая непродуманная до конца конструкция, и я сейчас не знаю, как ее сделать даже.
И во что переделать. 


Надо же так:
- каждый класс в цепочке абстракции может содержать запись агрегированных членов (<..>)
-- но классы внутри записи агрегации (между <>)не могут содержать агрегированные члены? Или могут?
- цепочка абстракции может содержать как минимум один класс и более.
- цепочка агрегации может содержать ноль класов и более. 