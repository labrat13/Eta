
21 апреля 2017 - инициализация проекта.


06 май 2017
- накидал несколько функций, но это не взаимоувязано.
- Общая концепция системы не сложилась, еще будет много изменений. Пока тут просто наброски, примеры  решений.
- добавлен шаблон БД в ресурсы сборки, написан код для его извлечения, не тестирован.
  - БД еще придется изменять, так что еще возиться с этим буду.
- написал тест для создания хранилища но он пока тоже несовершенен.
- Совсем не продумана работа с сессиями. Их надо изобретать полностью.
  + сделал создание временного каталога для сеанса. Тестировал.
  - теперь нужны функции, работающие с этой самой сессией.
  - надо решить, перенести все же туда совсем каталог хранилища из менеджера или нет?
- Адаптер БД накидано несколько функций для примера общей структуры.
- Контроллер архива - в начальной стадии.
+ Еще нужно сделать для файла описания хранилища что-то... 
  + в StorageInfo его перенести.
  + нужна функция создания файла из данных объекта StorageInfo
    + сделано чтение и запись
    + сделано создание файла
    + сделана загрузка файла в объект без менеджера.
    + частично тестировано это все.
    
07 май 2017
- подступился к добавлению новой сущности.
  + написал тест добавления сущности в хранилище. 
  - Но сейчас пока это все не продумано в теории, будет много переделок и ошибок.
  - написал функцию вычисления контрольной суммы файла, но она расположена не иам и вызывается невовремя.
  - написал еще несколько функций, но они не на своем месте вызываются.
  - надо концепцию прорабатывать - что и как и когда должно происходить и как все части системы должны работать.     

08 май 2017
+ написал все функции добавления нового документа
  + ничего не тестировал - завтра буду.
  - вообще - тяжело идет почему-то.
  + после тестирования надо так же сделать добавление нового изображения
  + а потом и запись собствено сущности в таблицу
  + потом надо попробовать это все обернуть в транзакцию. Чтобы вся операция откатывалась при возникшей ошибке.  
- тут возникла мысль, что все эти технологии программирования рассчитаны на кусочные работы. 
Какие-то отдельные работы, последовательности операций, можно представить алгоритмами.
Но на то, чтобы прямо всю некоторую деятельность представить алгоритмом, эта технология не рассчитана.
Получается такая кусочно-линейная интерпретация деятельности, 
состоящая из небольших автоматизированных отрезков, которые связываются собственно интеллектом пользователя.
Такой подход только предоставляет инструменты для пользователя, но не может его заменить.

09 май 2017
+ тестировал функции добавления документа - вроде все успешно.
+ написал весь код по добавлению сущности.
  + тестировал, вроде успешно.
+ обернул в транзакцию.
  + тестировал, вроде успешно. 
  - Откат транзакции не тестировал - не возникало ошибок пока.
- транзакция не откатится полностью, поскольку файлы уже добавлены в архивы. Но записи в БД не будет, и файлы просто занимают место в архиве.
  - нельзя просто удалить эти файлы через код-обработчик отката транзакции,
    так как нельзя без БД определить, новый ли это файл или уже где-то используемый.
    - можно по БД, но это слишком долго и сложно, чтобы делать просто как откат транзакции.
  - Их должен будет удалить оптимизатор. Но он пока не готов.
  - файлы занимают также и имена в архиве. Но пока я пробовал добавлять файл в архив повторно, с тем же путем и названием,
     и это не приводит к проблемам.     
- но остались еще случаи разнообразия входных данных - их не на чем проверять пока - нет массива входных документов.
  - нужен большой тест на большом массиве - на каком-то модуле свойств. 
     А для него надо писать специальный код теста и в нем отслеживать все эти ответвления алгоритма.
- надо вынести из классов мелкие статические функции в специальный класс утилит. 
   Это разгрузит основные файлы проекта.
- написал и тестировал получение записей сущностей
  - записи сущностей сразу же связываются с записями файлов
  - но вот ссылка на менеджер не добавляется в записи и сущностей и файлов.
    - для этого надо добавить ссылку на менеджер в сам адаптер БД. Через конструктор?
    - и чтобы все записи файлов и сущностей, получаемые от адаптера БД, имели эту ссылку установленной.
       Тогда в них будут работать функции вроде Получить файл или Записать изменения.
- написал и тестировал енумератор сущностей
- написал и тестировал енумератор документов     

10 май 2017
- надо бы хранить CRC как HEX в таблицах БД, но функция вычисления CRC отдает ее как Int64.
  И соответственно, во всех местах она используется как Int64, и переводится в строку.
  - можно, конечно, привести ее к UInt32, но зачем - хранить потом в записи файла 16 байт вместо 8 сейчас.
  - зато в БД будет всего 8 символов вместо 10 сейчас. Это ускорит поиск незначительно.
  - и у меня пока нет функции перевода из HEX обратно в число. А она мне и не нужна.
  - предлагаю отложить это на потом - когда все остальное уже будет решено. 
- надо сделать недоступную публично ссылку на менеджер в записях файлов и сущностей.
  + сделано. Это приватное поле, и оно инициализируется только в записях, созданных в адаптере БД.
    В остальных записях это поле = null.
  - надо проверить, что эта ссылка работает во всех ситуациях, когда она нужна.  
- Нужна функция для генерации квалифицированной ссылки на файл в хранилище, на сущность в хранилище.
  - она будет использовать ссылку на менеджер хранилища в объекте записи.
  - для этого нужно разработать формат таких ссылок.
    - для файлов он вроде уже определен.
    - для сущностей сложно - нужно различать их экземпляры записей.
    - еще надо иметь возможность ссылаться на отдельные поля записей. 
- надо сделать поиск по шаблону  для файлов и сущностей
  - отложить до конца основного объема работ - тут ничего сложного и рискованного нет.
- надо готовить большой тест проекта
  - это первый большой тест идеи проекта в целом и этого прототипа в частности.
  - большой объем данных, файлов и изображений.
    - наверно, крупный модуль свойств, содержащий документы и изображения.
  - проверим, как быстро это все работает
    - как работает добавление
    - как работает выборка по имени сущности
    - как работает енумератор сущностей
    - как работает енумератор файлов
    - сколько места занимает это хранилище
    - не теряет ли менеджер файлы, сущности.
    - нужно общее впечатление: удобна ли вся идея проекта в целом, или нет.
  - надо приготовить место для тестового хранилища.
  - надо написать алгоритм добавления данных.
- отчет по большому тесту
 - были замечены маленькие ошибки, вроде они все устранены, исключений при работе нет сейчас.
 - производительность низкая.
   - оказалось, что файл архива при добавлении записи перезаписывается полностью. Сам, через механизм обновлений.
    Причем предыдущие секции архива перезаписываются-копируются, а новая - надо смотреть исходники.
    Поэтому запись так медленно идет.
   - надо или делать сборку файла вручную через поток, или искать там есть флаг Прямое обновление - яхз что это такое.
     Или оставить все как есть, но тут уж очень медленно это все работает - для каждого нового файла перезаписывать весь архив - мутота.
     Можно уменьшить размер файла архива, это снизит время перезаписи. Но это тоже плохо.
     - флаг нельзя выставить, код зипования обещает ошибки в файлах при прямой дозаписи архива.
 - конечно, это хранилище сейчас рассчитано на медленное ручное добавление, но мне же надо много гигабайт в него прокачать.
    Это совершенно неприемлемая скорость сейчас.
   + предельный размер архива снижен с 256 до 64 мб. Это значительно ускорило импорт тестового модуля свойств.
   - запланирована специальная функция массового добавления сущностей. 
      Массовое добавление позволит сократить число операций перезаписи архива.
      Это должно смягчить проблему до приемлемого уровня.
 - статистика хранилища не вычисляется, и это не дает оценить свойства хранилища.               
- было бы надежнее хранить в сущности не первичные ключи записей файлов, а их архивные пути.
   Ведь если первичные ключи собьются, все эти связи файлов перепутаются. Без возможности их восстановить.
   Такого не должно случиться, если в БД никто не станет лазить. Но ХЗ, этого нельзя гарантировать.
   Все же БД имеют публичный формат.
   - первичные ключи там хороши, если надо организовать подстановку прямо в БД.
     Но пользователю это не надо - он вообще в БД лезть не должен никак.
     Так что лучше хранить в сущности именно архивные пути файлов. 
     Как в модуле свойств 1. Только это больше места займет.  
             
22 май 2017             
+ зарезервированные имена файлов: CON PRN AUX CLOCK$ NUL COM1 LPT1 LPT2 LPT3 COM2 COM3 COM4
  + надо добавить их в функцию исправления имен файлов. - done
- большой тест завершился большим провалом: файл архива не добавлял некоторые файлы даташитов, 
   а я не получил об этом сообщения - исключения, так как они отлавливались и глушились в коде.
   И только когда алгоритм не находил эти файлы в архиве для выявления дубликатов, я получал исключения.
   А теперь все результаты большой конверсии модулей свойств можно выбросить - проще заново их конвертировать, 
   чем выявлять и исправлять ошибки.
   - и я теперь даже не знаю, работает ли вообще зип-движок или он так и глючит случайно.

25 мая 2017
- решено использовать другой движок ZIP. Текущую версию архивировал. Возможно, я к ней вернусь если не получится с новой.
  - движок зипа искажает имена файлов.
  - движок зипа теряет создаваемый новый файл, и не выдает об этом исключение, а тихо откатывается к старой версии файла архива.
  - весь исходник этого движка зипа надо перепроектировать, но разбираться с ним не хочется. 
     Да и это не гарантирует более сложных проблем с форматом файла. 
  + Хорошо что я отделил движок зипа от моего кода классом ZipWorker. Теперь немного проще менять движок.
- Замена движка:
  - нашел и добавил в проект исходники IonicZip. Постепенно, папку за папкой, требуемые файлы. 
     Так получается минимальный набор нужной мне функциональности. 
  - Сейчас это компилируется без ошибок.
  - вроде все переписал как требуется, но!
    - все это надо переделывать! При работе с архивами могут возникать исключения. 
    И их надо как-то обрабатывать. А это не предусмотрено сейчас мною никак.
    Если ошибка при создании архива произошла - надо заново весь архив создать просто.
    Это возможно, хотя и сложновато.
    А если ошибка произошла при дополнении архива или удалении из него файла? 
    Опять же, надо просто восстановить архив и что-то попробовать снова?
    А это происходит в хранилище, где потеря данных архива недопустима.
    И что делать при ошибке?
    Прошлый менеджер это обрабатывал и откатывал изменения.
    А этот - нет, просто выбрасывает исключение и все... вроде бы, надо проверить.

26 май 2017 
- надо ли добавить лог в эту систему, чтобы проверять, что произошло при ошибках?
  - при отладке и первичном опыте использования лог полезен.
  - он временный на сеанс или пополняемый или перезаписываемый?
  - он общий для всех экземпляров или один на хранилище? 
  - он добавит сложности в систему, а будет ли реально необходим? 
- Надо перепроектировать весь проект заново.
  - Сначала надо протестировать, что сейчас работоспособно из функционала.
  - Теперь надо проектировать сверху вниз.
    - В коде много неэффективных решений и непонятных названий. 
       Но это только последовательными переделками кода можно улучшить. 
  - Надо ввести объекты транзакций, чтобы уже все было как в настоящей БД.
    - Транзакции нужны только внутри менеджера и только при изменениях архивов.
    - Без них в архивах будут оставаться файлы, успешно добавленные в неуспешной операции.
       Бд откатит транзакцию, и удалит записи о файлах, а сами файлы останутся. 
       А имена, которые они занимают, будут повторно использоваться, так как их нет в БД.
       И это будет вызывать исключения.
    - Транзакции будут управлять резервными копиями архивов, заменяя их обратно при откате транзакции.
       Или удаляя после принятия транзакции.
    - Резервные копии архивов надо хранить в папке tran\doc tran\pic сессии.
    - Объект транзакции будет хранить список резервных копий файлов архивов, измененных в течение транзакции.
       Имена файлов менять не нужно - они уникальные в пределах своей подпапки транзакции.
       - вот это копирование дополнительно замедлит добавление одиночного файла. Но это надо делать.  
    - Объект транзакции будет хранить список резервных копий файлов архивов, созданных в течение транзакции. 
      Чтобы удалить их при откате транзакции.
    - Объект транзакции будет создаваться так же, как в БД - в функции, начинающей операцию.
       И из него будет вызываться откат транзакции, так же как в БД.
       - Надо посмотреть, как там для БД это все устроено и работает в коде. Сделать подобное у меня.
  - Теперь чтобы сравнить файлы, надо либо извлечь файл из архива, либо дочитать его до конца даже при несовпадении.
    - Это замедлит сравнение - раньше при первом же несовпадении сравнение прекращалось. 
       Поэтому оно проходило быстро - извлекались лишь первые 4096 байт файла.
       Теперь придется весь файл распаковать, чтобы узнать что он не подходит.
       А заодно проверить, что он не поврежден. Все же польза.
    - надо переписать код на этот новый способ.
    - теперь сравнение будет выдавать исключения.
  - Надо написать собственное исключение менеджера - паковать в него все исключения,
     возникающие внутри менеджера и отдавать клиенту уже понятные причины ошибок.
- CRC32 класс использует динамическую генерацию таблицы, и ее можно бы переделать на статическую таблицу, однократно генерируемую.
  Иначе она будет генериться каждый раз, когда объект класса создается, и это должно быть очень долго, наверно.
  Нет, вроде нельзя - надо осмотреть все использования класса в коде зипа.
  - осмотрел. Лучше использовать свой статический CRC класс для хешей файлов. А архивам оставить свой, специфический.
    - Иначе надо постоянно держать где-то CRC объект с таблицей. А вроде негде. Лучше уж статический класс.
- надо вообще-то профилером померять - что жрет много времени и что можно оптимизировать.
  - CRC жрет много времени, конечно же.
  - собственно deflate жрет много времени - основная работа Zip.

- при обработке транзакций в КонтроллерАрхива надо помнить, что транзакция могла быть еще не совершена, а ее уже требуется откатить.
   Такой алгоритм у обработчика исключений.
- сделано сравнение файлов с проверкой целостности файла в архиве.
  - не тестировано.
  - это все будет медленнее, но высоконадежнее.
- все функции ZipWorker будут источниками исключений архива.
- Надо сделать собственный класс исключений Менеджера, 
   поскольку используемый сейчас класс Exception не позволяет 
   в вызывающем коде отдельно обрабатывать исключения из Менеджера.
  - Все функции Менеджера будут источниками исключений Менеджера.
  + StorageException добавлен
  - надо перепроектировать код с учетом возможных исключений и везде сделать чтобы он выдавал только StorageException исключение.
    - кроме проверок аргументов приходящих от использующего сборку кода.

28 май 2017
- сделал передние функции получения файлов
  + сделал рабочие функции. Тестировал. Вроде работает.
  - Надо сделать для них переупаковку возможных исключений.
  + сделал проперти получения квалифицированного имени файла в FileRecord. Его можно использовать для веб-подобных ссылок.
    - надо сделать такой же проперти для сущностей EntityRecord. Но пока не определен формат этих путей. 
      - Проблема с именами сущностей. Тут они не должны содержать пробелы. Но имена сущностей не должны искажаться в Хранилище.
         Придется искажать их в квалифицированном пути сущности, чтобы получить нормальный веб-путь.
         Все равно это нужно только для веб-подобных ссылок.
      - к этим веб-подобным путям еще нужен префикс вроде file:///, чтобы они стали путями.
         И как это будем обрабатывать? Класс QualifiedNameManager для этого нужно сделать нормально.
         А то сейчас там три функции.  
- сделал функцию получения квалифицированного имени хранилища из БД.
  - сделал имя публичным через проперти, но кому оно нужно публично?
    - можно переделать на internal. А вообще - вопрос: Менеджер как открытое Хранилище вообще 
       будет виден где-то, чтобы раздавать свойства хранилища так вот поодиночке?
  - тестировал. Работает сейчас.
- и еще много мелких работ сделал. Все компилируется, но не тестировал. 
- Надо сделать наброски для начала работ:
  - объявления функций пакетного добавления файлов
  - накидать класс транзакции контроллера архивов - накиданы основные функции.
    - надо добавить его создание в контроллере архива подобно тому, как в классе БД.
      - добавлено, но логики самой транзакции нет.
      
- О Транзакциях:
  - сейчас это однопоточная версия движка хранилища, которая проектируется для работы в одном экземпляре.
    И транзакции, соответственно, для одного выполняющегося экземпляра движка.
    А если этих экземпляров несколько, то работа транзакций становится сложной.
    И я пока не могу сказать, что именно происходит. Это надо планировать, проектировать.
    - пока будем делать эту однопользовательскую схему. Потом если надо, то усложним.
  - Даже если без транзакций, несколько экземпляров одного движка, работая одновременно, испортят хранилище.
     Если оно не ReadOnly.
     Это потому, что управление резервными копиями архивов встроено в сам движок зипа, а не отдано на управление в транзакции.
     - предлагается проверять наличие активной транзакции Хранилища и ждать, пока она будет закончена.
        В течение чужой активной транзакции движку нельзя читать и писать в архив.
        - чтение архива тоже означает создание транзакции - так как затем этот же архив может быть открыт для добавления.
          - или можно выставить FileShare.None при открытии архива на чтение. Но это можно сделать только внутри движка зипа.
             И тогда попытка чтения архива выдаст исключение, которое вызывающей программе скажет: попробуйте в следующий раз.
     - как проверить наличие чужой транзакции?            
         Где-то в каталоге хранилища надо создать файл лога транзакции, а в конце транзакции удалить его.
         Если файл лога транзакции существует, чья-то транзакция уже выполняется.
     - тут если все процессы хотят читать хранилище, то все их можно допустить.
       А если кто-то хочет записывать в Хранилище, ему придется подождать, пока оно освободится от всех читателей.
       Так что можно ввести таймаут для транзакции. 
       Если в течение этого времени транзакция не начнется, то вернуть ошибку истечения таймаута.    
     - Вообще-то, вся эта система уже отработана в множестве готовых решений. Надо просто где-то их найти и осмотреть.
     
29 май 2017
- тестировал созданные хранилища.
  - импорт из объединенных модулей свойств прошел успешно и довольно быстро.
  - тестирование получения файлов из хранилищ тоже не выдало исключений.
  - обнаружил, что через енумератор файлов выдается больше файлов, чем их есть в БД. 
	   Это странно, потому что файлы выдаются по ид, и он начинается с 1 и идет без промежутков.
	   И это проявляется только на больших выборках - более 400, а не регулярно.
  - вроде бы при этом сама структура данных в БД нормальная, и можно ожидать, что после отладки все это будет работать.
    - значит, можно уже помаленьку создавать хранилища из журналов и всяких подобных источников.
      - но надо сделать сейчас бекап движка и его исходников под эту версию - чтобы потом эти модули было чем читать.            
      
06 июль 2017
- оказалось, что очень медленно добавляяются файлы при их числе более 10000.
  Это тормозит запрос LIKE в FindUnicalFileName(). 
  И это никак нельзя обойти, поскольку надо искать имена в записях вида doc1/file.ext      
  Поэтому быстрые оптимизации тут нельзя сделать. Запрос LIKE так и будет тормозить добавление файлов.
  Добавление файлов происходит редко, а в чтении файлов этот код не участвует.
  Либо надо переделывать таблицу и всю архитектуру, а это тоже неприемлемо сейчас.
  - Есть решение:
    - нужно загружать из таблицы файлов имена файлов в отдельный словарь<string, int>, и в нем искать.
      + сделана функция Dictionary<String, int> GetFileNamesDictionary(String table), не тестирована.
    - словарь создается только в начале пакетного добавления файлов, вместе с остальными переменными этого пакета.
      ! нельзя создать - в этом месте нет доступа к адаптеру БД. И нет имени таблицы, в которой искать.
        - имя таблицы можно все же получить как-то.
    - словарь удаляется после записи всего пакета, вместе с остальными переменными, как они сейчас.
    - словарь 300000 записей по 16 байт занимает 30мб памяти.
    - это только для пакетного добавления файлов.
    - Это решение должно втрое ускорить пакетное добавление файлов.
- оказалось, файлы внутри одного пакета не проверяются на дубликаты и не обеспечивается уникальность их имен.
  В результате, они перезаписываются либо при помещении в временную папку перед записью в архив, либо в самом архиве.
  Хотя это я не проверял, но кода, проверяющего файлы в буфере пакета, нет! 
  Это надо полностью переписывать, создавать полностью новый алгоритм только для пакетного добавления файлов.
  - Это и будет незначительное изменение, новая субверсия движка. Надо запланировать эту работу.
  - уже существующие хранилища это вряд ли испортило, так как там обычно файлы в пределах папки, их имена уникальные.
    - но все же, могло несколько файлов потеряться.
     
09 июль 2017
- надо навести в проекте порядок - завершить все переделки и привести все в порядок и где-нибудь это все документировать.
- надо создать инфраструктуру для тестов переделок.
  - нужно большое хранилище
  - нужны файлы для добавления
  - нужно время, чтобы все это проверять.
- надо объединить ArchiveController.DocumentsDir и DbAdapter.DocumentTableName - они и одинаковые, и используются в одном смысле.
  - удобно оставить DbAdapter.DocumentTableName, использовать его вместо ArchiveController.DocumentsDir. 
     Но надо бы это как-то переназвать, что-ли? Или не надо переназывать, и так сойдет? 
     Неохота прорабатывать всю эту тему концептуально.
+ заполнение словаря из БД сделано.
+ надо сделать проверку дубликатов  и по внутреннему списку дубликатов, если он есть. Для этого нужна функция в ArchiveController.
  - поскольку там уже есть БД, то лучше туда и перенести весь код из Manager.findDublicate().
  + надо сначала просмотреть список в памяти, а потом уже обращаться к БД. Так повысится общая скорость добавления файлов.
+ надо сделать проверку имени по новому словарю имен. Если он есть. А если словаря нет, искать через БД как раньше. 
   Для этого нужна функция в ArchiveController.
- Сейчас вроде все переделки сделаны. В итоге получается, что всю работу с файлами можно перенести в контроллер архивов.
   Это можно переделать весь движок тогда. Но надо ли?
   - а сейчас в проекте бардак.Это нельзя так оставлять - потом не разгрести эту кучу переделок и недоделок. 
     А мне уже сейчас нужен стабильный релиз для работы с хранилищами.
- Следует ли внести также изменения в процессы одиночного добавления файлов? 
  - Это бы упростило движок, удалив неиспользуемые функци менеджера и повторно используя функции контроллера архивов.
  - Одиночное добавление также использует части пакетного добавления файлов, поскольку они одновременно могут использоваться.
     Значит, и код одиночного добавления тоже нужно переделывать.
     - но добавляемые пакетно файлы нельзя удалить - сначала они должны быть записаны в БД, то есть, все буферы должны быть записаны и очищены.
       Вроде бы это делается сейчас...   
- Еще надо протестировать все эти изменения. И затем перенести их на работу с картинками - они сейчас не переделывались.
- Все это добавление файлов надо тестировать как в пакетном режиме, так и в одиночном режиме. 
   И особенно - вперемешку, так как движок позволяет добавлять файлы одновременно и пакетно и одиночно.
   Хотя маловероятно, что он так будет использоваться пользователем. Но также предполагаются боты - возможно, они и будут такую мешанину создавать.
- тестирование:
  - при проектировании переделок я упустил из виду, что запись о добавляемом файле записывается в БД. 
     Это сам файл в архив не записывается, а хранится в буфере пакета.
     Поэтому запрос LIKE и запрос поиска дубликатов возвращает выборку из всех добавленных файлов.
     Поэтому запрос поиска дубликатов через пакетный буфер лишь немного ускорит выявление дубликатов 
      без обращения к БД и то очень редко это происходит.
     Но его все же следует оставить, раз уж я его сделал.
  + при первом запуске пакетного добавления для первого файла пакета уникальность имени проверяется по БД, 
     поскольку словарь имен еще не создан и не загружен.
     Второй и последующие файлы уже проверяются по словарю имен.
  + сейчас словарь имен не пополняется при добавлении файлов, это ошибка, которую надо исправить!                 
    + исправлено. 
    + Но и при одиночном добавлении файлов тоже надо пополнять этот же словарь. Если он существует.
      + сделано. Сразу после добавления записи о файле в таблицу он добавляется в кеш-словарь.
- надо изменить версию сборки на 1.0.1.1, чтобы отличать хранилища, созданные переделанным движком.
  + сделано
  - надо описать переделки в описании новой версии. 
  - Эта новая версия сейчас считается предназначенной специально для процесса добавления патентов. 
          
2 октября 2017
- Новый заход на проект - изготовление приложения для поиска в хранилищах.
  Это прототип для браузера хранилищ. Это приложение введет в оборот созданные мною хранилища.
- Сейчас это прототип, который я разрабатываю обычным для себя интуитивным способом. 
   Поэтому в проекте бардак и все на ходу придумывается. Что-то я устал от разработки концепций.
   Но и от разработки кода тоже устал. 
   Короче, этот прототип потребует анализа и переделки в более структурированный и правильный объект.
   Поэтому сейчас надо все это проще делать - надо успеть закончить прототип до того, 
    как бюджет драйва и времени на него закончится. 
   И в движок Хранилищ не лезть - иначе я там напортачу и все это зависнет надолго.  
- Функциональные требования:
  - Это приложение, запускающееся с ярлыка на рабочем столе. С инсталлятором.
    - Надо подобрать большую красивую характерную иконку для приложения.
  - Главное - поиск и получение описаний и файлов. А то я упаковал все в Хранилища, а теперь 
     никак не могу что-либо использовать. А надо иногда.
    - запрос типа LIKE на первое время хватит, как в инвентарь - галочками выбирать поля для поиска 
       и так же формировать запрос для поиска. 
    - выбрать для поиска Хранилища как места-контейнеры для поиска, деревом с галочками или списком с галочками.
      - проще деревом, если Хранилища в папки-категории организованы. 117 Хранилищ журналов будет долго отмечать галочками в списке.
         Быстрее их каталог отметить.
      - Надо выбирать и по Характеру Хранилищ тоже - радиодетали не искать в патентах.
       Как это организовать? Тоже галочками? Или деревом Хранилищ с галочками? 
       Или списком галочек тем хранилищ? Надо придумать потом. 
    - выбрать для поиска классы сущностей. 
      - Эти классы надо сначала собрать в единое дерево, а потом по ним тоже искать - если искать
         выборочно внутри определенных классов сущностей.
      - поиск по классам требует полного перебора всех записей БД кодом, не запросом.   
      - Классы сущностей определены и для Хранилищ. Можно по ним отбирать Хранилища для поиска.   
    - какие поля доступны для поиска?
      - cat содержит класс сущности. 
      - name - название сущности
      - descr - описание сущности
      - doc.descr - описание файла документа
      - pic.descr - описание файла изображеня сущности
    - Надо сделать отображение результатов поиска - подобно гугловым? Чтобы сразу было ясно, что именно нашлось.   
  - Получение файлов и изображений для найденных сущностей, показ изображений, 
     редактирование данных записей Сущностей. 
  - создание новых записей Сущностей, прицепление файлов и изображений также.   
  - Хранилища прописать в настройках приложения как пути к папкам с хранилищами. 
     Пути могут быть недоступны. Для показа этого списка потребуется форма или дерево с галочками.   
     Но не все хранилища поместятся на винт компа, часть Хранилищ будем брать с архивного винта, 
     когда он доступен. Поэтому не ругаться, если Хранилища недоступны.
- Это все такое концептуальное, его не сюда в ТОДО надо писать, а в вики проекта перенести как обсуждение интерфейса приложения.
  Получаются элементы интерфейса:          
  - дерево классов сущностей для поиска по классам.
  - дерево мест с каталогами Хранилищ.
  - строка ввода поискового запроса.
  - галочки выбора полей.
  - окно списка результатов, выбор переводит на карточку элемента.
  - немодальная форма карточки элемента, в ней пользователь может:
    - получить файл документа
    - просмотреть изображение
    - просмотреть и изменить описание элемента
    - просмотреть и изменить название элемента
    - просмотреть и изменить класс элемента.
    - вставить изображение
    - вставить файл документа
    - удалить запись карточки
    - сохранить запись карточки
- Накидал интерфейс главного окна. Вроде все работает как должно.
  + иконки насобирал для деревьев и приложения в целом.
  - теперь надо планировать внутреннее устройство программы.
    - где хранить список путей к местам?
      - в собственном файле настроек?
    - где хранить список классов сущностей в хранилищах?
      - в собственном файле настроек, по каждому хранилищу отдельно?
    - когда сканировать хранилища в поисках классов сущностей?
      - после добавления нового хранилища?
    - как добавлять пути к хранилищам?
      - диалогом, сразу несколько, чтобы хранилища сканировать только после добавления всех хранилищ?
      - автоматически искать на всех дисках, по структуре папок и файла описания хранилища выявлять хранилища.
        и по окончании поиска хранилищ их все добавлять (если еще их нет) и потом уже сканировать классы.
      - проверить сначала, что те пути что уже есть, верны - там есть эти хранилища.
         Если это не так - показать хранилища в дереве мест красными значками ошибки.
    - как показывать объекты в дереве? Я нашел иконки, но не все наверно.
      - папки - значками папок.
      - классы - значками класса
      - хранилища - значками БД
      - ошибки - значками ошибки
    - как показывать результаты в списке?
      - пример кода из Инвентарь - там есть все это, только надо решить, как это удобно представить
         Это непросто - названия длинные, а окна короткие.
         Тут лучше бы список из больших панелей, как в википаде - но его надо делать самому.
         Кастомный контрол.                

04 октября2017              
+ добавил чекбокс искать в найденном
+ сделал в настройках списки строк - ранее планировал в хмл, но там 
   есть тип SpecializedString, он как раз в хмл все сохраняет - все само делается.
  + переделал код работающий с этим, компилируется.
+ тестировал сохранение галочек и получение строк из настроек - работает.
+ добавил форму редактирования мест и связал ее с перезагрузкой дерева мест.
  - если пользователь укажет места неправильные, приложение вылетит и 
     неправильные места не запишутся в настройки приложения. 
     И при следующем старте приложение запустится с старым, правильным, списком мест.
     Это повышает надежность работы приложения.
  + все работает как ожидалось.
  + надо таб порядок настроить в обоих формах - сделано.
+ сделал функцию менеджера списка запросов private void AddQueryToListUsedQueries(String query) 
   Она добавляет запросы если они уникальные, и регулирует длину списка запросов.       
  + сделал загрузку запросов из настроек через эту функцию.
- сканирование Хранилищ из путей:
  - теперь объединено с  сбором классов из хранилищ в список классов. 
     Который теперь не сохраняется в настройках приложения, так как зависит от Хранилищ. 
  - Но классы выводятся в дерево классов отдельной функцией internal void LoadClassesTree(TreeView tc)
     которую надо вызывать каждый раз после сборки дерева мест и Хранилищ.
  + Надо сделать извлечение классов из хранилищ в private bool AddStoragePathToList(string path)
    + сделано - классы собираются в список классов, где они без повторов.
- дерево мест и Хранилищ
  + вроде собирается.
  - галочки нод надо как-то обрабатывать - сами они не распространяются по дереву.
    - кликнутую ноду и все дочерние ноды установить в состояние кликнутой ноды.
      - сделал такое, но теперь нельзя выбрать только сам класс, без его дочерних классов.
        - после экспериментов решено его отдельно цеплять к собственной ноде как типа только самого себя.
          Но это выглядит странно - надо визуально его выделить и потом при сборе списка классов для поиска тоже отдельно обрабатывать.
          И это делать только для нод с субнодами. А это требует постобработки дерева после сборки.
           
    - (облом) Для каждой родительский ноды вверх к корню - установить состояие по их субнодам:
       если все субноды разные, установить значение неопределенное. 
       иначе установить значение из субнод.
      - нельзя! Для чекбокса ноды нет неопределенного состояния.
      - верхние ноды лучше не изменять, иначе все дерево нельзя будет настроить.  
  - надо собирать из них список хранилищ в которых разрешен поиск, исключая неисправные. 
- дерево классов
  + сборка дерева уложилась в одну функцию. Неожиданно получилось... 
  - галочки нод надо как-то обрабатывать - сами они не распространяются по дереву.
  - надо собирать из них список классов, в которых разрешен поиск.
  - искать по классам сложно, так как только код может сопоставить классы. 
     В Хранилищах нет точных названий классов и четкой системы обозначений, поэтому 
      имена классов нельзя использовать в SQL-запросах.
  - надо привести классы в Хранилищах к единой системе обозначения, записи.
    - сначала надо создать эту единую систему обозначений. Дерево классов и будет ею. 
    - из того дерева, что сейчас видно, Дисплей это подкласс Индикаторов. 
       Так-то оно так, но дисплеи уже самостоятельная крупная и важная категория.        
- поиск в Хранилищах
  - функция поиска: internal String[] Search(String query, SearchCheckboxStates fields, String[] storages, String[] classes )
  - поиск по LIKE уже есть в адаптере БД хранилища. 
- инсталлятор
  - заниматься им буду ближе к релизу, сейчас некогда. Схема с инсталлятором отработанная.  
- Для преобразования классов - цитата из вики проекта:        
* Хранилище должно содержать только сущности некоторого класса и его подклассов. 
   Этот класс указывается в свойствах Хранилища, в [PropertyModule2/ФайлОписанияХранилища] 
    поле [PropertyModule2/КвалифицированноеИмяХранилища]. 
    (В измененном виде: вместо :: разделителем классов является точка.) 
    Этот класс является базовым классом Хранилища. 
    * Если сущность относится к подклассу базового класса, в поле категории вписывается 
       вся ветвь подклассов, идущих после базового класса.
    * Если сущность относится непосредственно к базовому классу, то в поле категории 
       вписывается название этого базового класса. Алгоритм должен это распознать и 
       правильно подставить значения.
    * Если сущность не относится к базовому классу или его подклассам, то она не должна 
       храниться в этом Хранилище. 
       
05 октября 2017
+ сделал дерево классов.
+ сделал галочки в деревьях. Теперь в обоих контролах единообразно чекбоксится узел и все его дочерние узлы.        
   Это лучшая схема из трех, что я перепробовал сегодня. Но дерево классов выглядит странно.
   В нем есть [классы] как группы и классы как экземпляры. 
   Это нужно, чтобы можно было, с одной стороны, выбрать сразу всех членов группы.
    А с другой стороны, выбрать только экземпляр класса. 
   Чтобы искать только Радиодеталь, но видеть все дерево в естественном виде.
   Вот такая вот особенность. А так все хорошо, единообразно, удобно получается.
+ надо сделать сбор Хранилищ для поиска. Вроде просто. Но голова уже не соображает, нужен отдых.
  + сделано.
- надо сделать сбор Классов для поиска. Тут все непонятно.
  - как выглядит поиск по классам?
  - в каком виде должны быть записи классов?
  - как я длжен устроить это хранение имен классов в нодах дерева, чтобы легко и быстро их собрать для поиска.
  Вот эти вопросы я решил отложить, пока не будет готов сам поиск по хранилищам.
  А потом вернемся к этому.   

06 октября 2017
+ поставил на комп хранилища радиодеталей для теста.
  - тест прошел успешно.
  - приложение загружается долго. Надо что-то придумать - сплешскрин показывать в это время с прогрессбаром?
  - дерево классов, конечно, огромное. в нем легко потеряться.
- 48 мб оперативки занимает приложение. Это из-за этих не используемых толком списков и огромных деревьев классов.
    - Значит, придется контролировать еще и объем свободной памяти при поиске. 
      Тогда и поиск надо переделать - вместо одной функции вызывать несколько, каждую для своего хранилища. 
      Показывать окно-прогрессбар поиска и в нем названия хранилищ указывать. 
      И кнопку Стоп, которая останавливает процесс поиска и отображает результаты.
      И процесс поиска должен остановиться, когда объем занятой приложением памяти превысит некоторый предел. 
- сейчас надо сфокусироваться на собственно поиске. Пока по LIKE. И отображении результатов поиска.
  - поиск по LIKE нечувствителен к регистру символов. Пока это хорошо.
  - поиск в 5 хранилищах по * занял всего 80мб ОЗУ.
  - нужна хорошая иконка для списка результатов.
  - сортировать иконки в списке результатов.
  - надо по клику на элементе списка результатов показывать его карточку элемента. Там в ней все редактирование и производить.
+ сделал для случая поиска в Хранилищах предел расхода памяти Form1.m_RamLimitForApplication, берется из настроек приложения.
   Если он меньше 64мб, он устанавливается в 64мб. Сверху ограничен размером Инт32: 2гб, этого достаточно.
   В настройках он 256мб, и средств для его настройки через ГУЙ пока нет.   
- накидал функции для поиска по всем флагам и случаям. Но они пока не готовы, поэтому флажки на фоме не включать.
  - internal void SearchInResults(ListView lw, string query, SearchCheckboxStates flags, string[] classes)
  - private static bool SearchInString(string query, string text)
  - private static EntityRecord[] SearchFullEnumeration(String query, Manager man, string[] classes, bool searchInTitle, bool searchInDescr, bool searchInDocDescr, bool searchInPicDescr)          
- надо отработать все TODO по этому проекту
- поиск по классам все еще не придуман. Хотя уже знаю, куда его вставить.
- что еще сделать по проекту:
  - сделать запоминание последних запросов
  - сделать запуск поиска по Энтер после ввода запроса - как в Инвентарь.
  - сделать объект классификатора - он должен получать строку цепочку классов, парсить ее на классы и опознавать классы по их именам.
Этот объект классификатора пока держать в поисковике, а потом встроить в объект сущности как объект-хранитель  категории сущности.
  - сделать формирование ссылки на объект сущности из самого объекта сущности. Эта ссылка нужна для получения сущности из хранилища - при показе карточки сущности при клике по окну результатов поиска.
  - сделать поиск по классам - это тот же поиск по query, но затем результаты дополнительно отбираются по их классам - в коде поисковика.
  - сделать показ несколько независимых карточек элементов.
  - сделать меню приложения - пункт закрыть.
  - не сохранять галочки классов и мест в настройках - пока не надо.
  - пока просто показывать свойства элемента в карточке элемента.
  - если галочка поиск в найденном включена, искать в объектах элементов, которые надо сразу вписывать в поле Таг в листвиевитемах. 
     Это значит, поиск будет уже тут а не в БД.
  - надо еще таки сделать нечеткий поиск подобных слов, но его только кодом можно сделать, он будет медленным.
  - надо подумать о том, как выявить и удалить эти дубликаты записей, которых много по всем Хранилищам. 
     Так можно уполовинить размеры хранилищ без потери данных.   
  
08 окт 2017
- сегодня нашел баг в менеджере хранилищ: (bugfix 08102017) не были закрыты потоки файлов 
   при проверке КС файлов и при сравнении двух файлов.
   Из-за этого перемещение файла после проверки его на наличие в хранилище функцией 
    man.FindDocumentDublicate(file) выдавало исключение "Файл занят другим процессом".
   А вот копировать его было возможно. 
  + теперь все работает как надо.
  - для проекта все-таки надо вести учет багов и фич. Причем не внутри проекта, а держать на компе утилиту для такого учета по всем проектам.
     Я где-то видел такую прогу, на дисках у меня была. Года так 2003. Рядом с Rational Control Center. 
     Я ее еще описывал в каталоге софта, помню. Тогда она не была полезной, а сейчас вроде бы и нужна - сейчас у меня много своих программ.  

11 октября 2017
- надо найти решения задач чтобы продвигаться к результатам проекта:
  - показать сущность в форме карточки сущности:
    - не закончена форма карточки сущности EntityForm
      - документы натаскивать на форму и стаскивать с формы на рабочий стол, открывать двойным кликом по окошку на форме.
      - надо два пикчербокса - для изображений побольше, для документа поменьше.
        - надо картинки - иконки для показа типа документа сущности в его пикчербоксе.
      - комбобокс для классов сущности:
        - классы брать из хранилища сущности или (лучше) классы брать из общего списка классов сущностей и вычитать из них базовый класс хранилища.
          - где брать общий список классов?
        - разрешать вводить новые классы в комбобокс.
        - сортировать по алфавиту, образуя плоское дерево классов.
      - надо меню действий или кнопками обойтись?
        - загружать изначально в режиме только для чтения
        - команда записать изменения - Сохранить?
        - команда перезагрузить форму из хранилища - Обновить?
        - если окно закрывается, и были изменения, запросить их сохранение, как в Блокноте.    
    - private void Form1.listView_Results_ItemActivate(object sender, EventArgs e)  обработчик клика по результату поиска в списке результатов.
      - не закончен, так как нет формы карточки сущности и нет линка на карточку сущности и хранилище.
    - private static EntityRecord[] StorageSearcher.SearchFullEnumeration(..) - искать полным перебором элементов хранилища
      - не закончена - нужен поиск по классам, а пока его нет никак.
    - public ResultItem.ResultItem(EntityRecord entity) - Тут надо вписать не ид таблицы а ссылку на сущность и хранилище
      - нужна ссылка на сущность и хранилище, получаемая из объекта EntityRecord. Но ее там сейчас нет.
        - нужно добавить туда поле, проперти или функцию для получения этой строки ссылки.
        - нужно описать формат этой ссылки, если его еще нет в концепции.
          - по имени сущности?
          - по идентификатору таблицы сущностей?
        - нужно придумать способ разбора ссылки на путь к хранилищу и сущность в хранилище.
  - классы сущностей:
    - надо сделать объект описания класса сущности и вставить его в EntityRecord (вместо поля класса?)
      - надо разработать формат записи классов сущности
      - надо разработать объект описания класса сущности с учетом потребностей в его использовании.
      - надо разработать парсер записи классов сущности
      - надо описать работу с объект описания класса сущности и добавить его в концепцию.
        - и добавить объект и концепцию в мою библииотеку классов - я еще намерен его использовать в других проектах.. 
        
15 октября 2017
- начал новую версию  1.1.0.0 причина: переделка поддержки классов сущностей.
  - QName перенес в отдельное namespace ClassificationEntity. Туда же добавлять все классы для работ с классами сущностей.
  - QName пока оставим так как есть - из него будем получать БазовыйКлассХранилища. И его же будем собирать при создании хранилища.
    - тогда зачем новая версия, если все останется как и было?
      - потом я переделаю - заменю его на БазовыйКлассХранилища, когда определюсь, что и где переделывать надо.
    - QName нужен для быстрой проверки или создания ссылок - поэтому его лучше бы держать в менеджере хранилища.
      - а БазовыйКлассХранилища нужен для всех работ с классами сущностей, записями сущностей. И его тоже надо бы держать в менеджере хранилища.
    - мне не хочется полностью пересобирать 120 хранилищ из-за этой переделки. 
      - Но их все равно переделывать - из-за классов сущностей. И это проще, чем собирать их в первый раз из мусора.
- сделал тег THEME: QNAME для обозначения всех мест где надо что-то переделывать по этой теме.
  - расставил везде где мог найти.
- сделал поля и проперти для БазовыйКлассХранилища в Manager и StorageInfo классах. Не тестировал!!!
  - сделал их загрузку при открытии хранилища.
  - сделал сборку QName в StorageInfo при изменении Title или StorageBaseClass пропертиесов. 
    Но это неправильная схема получается. 
    Она наверняка будет плеваться исключениями при работе. 
    Ее надо переделать.
- название хранилища не должно содержать символов, из-за которых парсер будет неправильно работать или файловая система.
  Сейчас пользователь соблюдает эти соглашения, но это неправильно - он не должен обо всем этом помнить.
  Надо проверять это сразу на присвоении названия хранилищу в StorageInfo и выбрасывать исклчение.
  Для этого надо создать функцию проверки и очистки, которая будет проверять символы и выбрасывать исключение.
  А заодно удалять повторные пробелы и триммить пробелы на концах.
  И прямо в проперти ее вызывать.  
+ сделал класс ClassItem для хранения и разбора классов сущностей.
   Разбор записи абстракции без записи агрегации.
   Тестировал, сейчас все работает как положено. 
  - сделал две функции вычитания классов. Работают вроде одинаково пока. Тестировал.
    public static string SubtractClassPath(string classPathString, string baseClassPathString ) 
  - надо переделать код в EntityRecord и еще где это используется. 
    Использовать этот класс вместо поля категории.
    и потом править весь движок в местах использования этого поля.
  - надо сделать затем поиск по классам в  StorageSearch.StorageSearcher классе.
    там перебирать все записи прямо и отбрасывать все что не подходит для выбранных классов.
    а в остальном искать. 
  - тестировать на хранилищах нельзя, пока у них неправильный QName - надо вручную исправить его на новый формат.  

16 окт 2017
- сделал класс LinkBuilder для создания и разбора ссылок.
  - поддерживает ссылки на хранилище с и без оконечной /
  - поддерживает ссылки на записи по ид таблицы (плюс, опционально, название элемента - его может и не быть)
  - поддерживает ссылки на файлы по архивному пути в хранилище
  - тестировал основные варианты.
  - написал функцию безопасного разбора ссылки - для работы со ссылками.
     public static LinkBuilder TryParseLink(string linktext)
- пробую вставить класс ClassItem в EntityRecord  
  - вроде вставил, ошибок компиляции нет. Надо тестировать, а нет ничего. Я уж и забыл всю инфраструктуру для этого.
    - вот предлагалось в умных книжках - писать тесты юнитов сразу и даже еще до написания кода. 
       сейчас бы тесты прогнал - и немного проще сразу бы стало.
       - тесты писать некому.
       - тесты хорошо писать, когда вся архитектура уже определена. А когда она на ходу придумывается - тесты это тяжелая и лишняя работа.
         Зато они обеспечивают предсказуемость проекта. 
       - тесты это же надо отдельно писать. А у меня тесты обычно с работой совмещаются - конверсией набора данных.
         Тесты хорошо писать, когда ты работаешь над проектом отдельно от его применения. Тогда можно иначе к этому процессу относиться.
         А у меня все в куче - и проектирование, и описание, и разработка и применение. 
         Так получается быстрее, но грязнее и ненадежнее - и сам проект и результат и последующее его использование. 
         Это же прототип. А переделывать его набело - некогда и невыгодно. Работает и хрен с ним.
    - тестировать будем на создании нового хранилища или на добавлении в Радиодеталь (конечно, временную копию Хранилища) новых сущностей.
      - сущности уже подготовлены, но хорошо бы их забекапить, пока не началось
      - а после тестирования надо допилить остальные фичи и протестировать пользование тестовым набором хранилищ.
      - а потом надо конвертить все Хранилища под новую систему классов.
      - а потом надо уже все их развернуть для использования и начать пожинать плоды моей работы наж всеми этими проектами.
        - плодов там мало и они невкусные. Но надо попробовать.     
- классы для документов и изображений сейчас вводятся текстом. 
   Иерархии классов для них пока нет, брать базовые классы тоже пока неоткуда. 
   Можно предложить из свойства хранилища Тип хранилища, но там тоже все примитивно, тоже надо это прорабатывать.
   Поэтому с категориями для FileRecord класса сейчас ничего не меняется. Оставлю это на будущее.
- надо составить схему как используются ссылки и квалифицированные имена для доступа к записям и файлам.
  - генерацию ссылок я сделал. Теперь надо это проверить.
  - с менеджера все начинается - в него отправляются ссылки. Наверно в один приемник.
    - ссылку можно получить из FileRecord или EntityRecord. Или это ссылка на хранилище - пока я не знаю, зачем она мне нужна.
    - ссылка на хранилище вернет свойства хранилища?
    - ссылка эта обменивается на соответствующий ей объект. Это или файл, или запись.
      - как можно отдать файл? Для этого нужен еще путь к создаваемому файлу.
    - Эта ссылка отправляется реестру хранилищ. Он возвращает соответственно путь хранилища и 
       приложение открывает хранилище и получает свой объект или файл, вызывая известные ему функции Хранилища.
    - пока надо сделать ссылки на EntityRecord, а потом определимся, что и как. 
  - а как обновлять записи файлов? вроде в менеджере нет таких функций пока?
    - и в бд адаптере тоже нет - вставка есть. А это нужно вообще-то? Надо подумать.
    - но если потребуется - то и сделаем, недолго это. Там главное ИД не менять и путь к файлу в архиве.
- вот только сейчас я подумал, что можно же было использовать поле StorageType  для базового класса Хранилища! 
  Оно там как раз для этого. И тогда не мудрить всю эту хрень с двойным именем хранилища в квалифицированном имени.
  Надо просто переписать все их в хранилищах в единой иерархии и сделать извлечение базового класса из этой нотации.
  - а сейчас опять все переделывать, почти что обратно.
  - надо выяснить, почему эта мысль мне сразу в голову не пришла - почему?
    - я забыл детали проекта, да и они не были хорошо проработаны в этой области.
    - текст в концепции не описывал это поле как БазовыйКлассХранилища.
    - значение этого поля в Хранилищах не наводили на мысль о  том что это и есть БазовыйКлассХранилища.
    - я был очень занят, увлекшись процессом разработки, и не мог посмотреть на проблему со стороны. 
       До тех пор, пока она не стала выглядеть решенной.                
 - сделал в браузере ссылки - теперь они показываются по клику.
   - оказалось, я неправильно написал код обработки результатов поиска - но теперь все исправлено.
   - в листвиеве не хватает иконок, есть ли у записи документ или картинка.
     - а там вообще можно иконки показывать, или нужен другой контрол?
     - можно добавить поля-флаги в ResultItem, и заполнять их если есть документ или изображение. Это легко.
       Но можно ли показывать иконки в листвиеве? а то текстом неудобно.
       Можно показывать их галочкой V
       Может, вместо листвиева использовать дбгрид? он дубовый, но флажки или иконки он показывать сможет, если поискать.        
     + сделал, сейчас показываются галочкой V. Может, и иконкой можно - не узнавал еще.
       - выглядит удобно вроде бы.  
 
17 окт 2017
- сделал показ свойств сущности, картинки в миниатюре и открытие документа.
  - открывается до 10 документов одновременно. А то так обламывает их все по одному открывать-закрывать.
  - вот еще бы и карточки не по одной открывать...
- работы по проекту наметились:
- надо доделать поставленные в тодо и тут задачи, и почистить проект - много хлама тут накопилось.
- надо перевести обратно классы в использование StorageType а не qname. 
  - Для этого надо переписать парсер qname обратно, но теперь уже лучше.
  - исправить обратно поля в тестовых хранилищах.
  - запланировать переделку поля StorageType во всех хранилищах на более правильную в соответствии с иерархией классов, которые также надо составить.
    - тогда и qname изменятся тоже - по этой же классификации. Их тоже надо будет переделать.
- надо допилить переход по ссылкам в хранилище. Сейчас в этой области бардак.
- по браузеру:
  - надо сделать форму показа карточки сущности и показывать карточки сущности.
    Пока без их изменения.
  - надо найти форму создания нового хранилища и переделать ее в соответствии с новым решением 
    - убрать текстбокс qname, собирая его значение из классов и названия хранилища.
    - решить, где создавать новые хранилища - в браузере или в отдельном приложении.
      - данные же в Хранилище запихиваются специально написанным конвертером - зачем создавать отдельное приложение или впихивать это в браузер?
      - может, извлекать данные прямо из ксв-файлов тогда этим общеупотребительным конвертером?
        - вряд ли, они обычно требуют обработки, которую я вручную не хочу делать. 

18 окт 2017
- провел тест на большом наборе хранилищ
  - В целом, выглядит это круто. 20Гб данных просматриваются за 5 минут.
  - первая цель проекта достигнута: я имею набор хранилищ данных и браузер для их просмотра.
    - конечно, пока все это сырое, но потом можно допилить. Если выделять на это время.
  - патенты сильно тормозят поиск. По 10 минут на хранилище.
  - в листвиев результатов поиска сейчас выводятся все найденные элементы. 
     Это сильно замедляет работу приложения. Неприемлемо. 
     Но поиск в найденном будет использовать их для поиска в них.
     - не все найденные элементы перегружать в листвиев - только 4000, остаток хранить в глобальном списке результатов поиска. 
  - иконка в результатах поиска мелкая и непонятная. 
    - надо найти лучшую иконку - что-то крупное и простое.   
  - окно прогресса толком не работает. Оно сделано наспех, показывается неправильно, 
    и кнопка останова не получает фокус, поэтому в нее надо попасть мышкой.
    И это работает через раз - эту штуку надо перепроектировать, чтобы с фоновым потоком работала.
  - инсталлятор:
    - сделал  InnoSetup наскоро - работает.
    - надо наполнить актуальным содержанием файл Readme.txt - сейчас там наброски.
       
  - в главном окне:
    - некоторые хранилища в дереве мест помечены знаком ошибки - они читаются неправильно при извлечении из них классов 
     во время загрузки приложения. Это из-за ошибок в классах - сейчас другие Хранилища показаны неправильными. 
    - Хорошо бы выбранные результаты поиска перетаскивать кучей или поодиночке в Блокнот или как ярлыки в папку, как ссылки на записи хранилища.
    - при просмотре или изменении мест поиска хранилищ, после показа окна происходит перезагрузка деревьев из хранилищ. 
      Прогрессбар в этом случае не показывается сейчас - надо это исправить.
    - поиск в найденном и свойствах файлов не реализован.
    - последние запросы (в комбобоксе запросов) не запоминаются и не пополняются.
          
  - При старте программы;
	- показывается окно прогрессбара, но кнопка там в это время  явно лишняя.
	- дерево мест загружается около минуты. Это слишком много, если надо быстро посмотреть что-то.
	  - надо сохранять списки мест и классов или дерево целиком в файле настроек приложения.
	     Тогда загружаться приложение будет быстро, а потом просто надо проверять что Хранилища на месте.
	     Если это не так, то выполнить пересканирование Хранилищ и классов в них.
	     А если пользователь добавил новые Хранилища, он должен указать их в местах.
	     - пользователь ничего не должен тут. Поскольку я забуду об этих требованиях, и все будет как всегда.
	       - тогда придется мириться с тем, что есть сейчас. Сейчас все найденные хранилища автоматически подцепляются и используются.
	         А если загружать из списка, то новые хранилища придется вручную  указывать или запускать пересканирование мест.
	 - выводы: 
	   - Пересканирование мест проводить по выходу из формы мест, или по обнаружению неисправных хранилищ, или просто периодически - каждый десятый запуск программы.
	   - Хранилища предполагаются постоянно, стабильно существующими и не изменяющимися по содержанию,
	      а запускаются они сейчас часто. Выгоднее ускорить запуск, а возможные проблемы будем решать по ходу их возникновения.  
    - в режиме бегущей волны при загрузке приложения прогрессбар неправильно отображается - только 3% шкалы и ничего не бежит.
    - дерево мест развернуто неудобно - надо разворачивать его только до развилок нод. 
      А сейчас оно занимает все место и его надо сворачивать вручную с прокруткой - очень неудобно на маленьком экране.
    
  - на форме карточки сущности
    - нужна кнопка для извлечения документа в указанную папку.
      тут лучше кнопка, так как перетаскивать некуда - глвное окно приложения обычно развернуто на весь экран.
      А иначе в деревьях ничего не видно и в результатах поиска тоже.
    - надо переделать весь расклад - окно должно растягиваться, чтобы можно было удобно читать длинные строки описания и названия.
      И контролы тоже растягиваться, кроме окна изображения.
    - нужен чекбокс Закрывать при показе документа. Если установлен, окно закрывается после отображения документа. 
       Состояние чекбокса сохранять в настройках приложения. 
       Сейчас надо после просмотра даташита еще форму закрывать. Это неудобно. 
  
  - Хранилища:
    - надо создать новую цельную классификацию для Хранилищ. Пока они так все вместе собраны у меня.
    - надо обеспечить использование этой классификации для этого и всех моих приложений.
      Как единый механизм и методику. Чтобы пользователь мог выбрать правильный класс, а приложение могло 
      проверить класс, в любом месте, где это требуется.
    - Эти работы с классификацией сущностей - это отдельный проект:
      - собрать воедино классы сущностей
      - создать единую классификацию, с возможностью пополнения и переделки.
      - создать методику записи классов и разбора классов.
      - создать средство хранения и описания классов (Базу данных?)
      - создать код для всех операций с классами.
      - создать способ и средство использования классов в сторонних приложениях.
      - описать методику создания, изменения, добавления, удаления, описания классов.
      - описать общую структуру классификации сущностей и цели ее разработки и содержания.
      - ...
    - надо описать стратегию использования системы Хранилищ. Правила для создания, изменения и управления Хранилищамию.
       - надо выделять время периодически на работы над этой системой.
       - надо преобразовать ее в отдельную группу проектов (Тему), еще не завершенную.
          В нее входят сами хранилища, размером 220гб, они должны храниться отдельно.
          С указанием ссылок на остальные части системы проектов.
          - каждая работа по этой теме должна быть в виде проекта. 
            После завершения он переносится в папку темы в виде архива.
            До завершения он хранится вместе с другими проектами.
          - в папке Темы хранятся также входящие материалы - наборы новых данных для Хранилищ.
            Это можно видеть в проекте Radiobase - там иногда добавляются новые комплекты данных, 
             а вносить их в хранилища это отдельная работа, которую надо продумывать, планировать.  
        - Темы надо потом увязать с проектом планера задач - там нужен этот опыт работ с темами.
    - надо переделать свойства Хранилищ: StorageType и QualifiedName в соответствии с новой классификацией.
    - надо изменить классы Сущностей в некоторых случаях
    - надо написать конвертер классов и qname хранилищ - их около 100 штук, вручную переделывать очень долго.
      - все изменения требуются только в БД.
      - БД можно получить выборкой файлов *.mdb из каталога. И потом просто делать требуемые работы, не запуская Движок.
      - надо извлечь все требуемые значения в ксв-файл, исправить их вручную и вписать обратно этим конвертером 
    - надо в описания журналов Радио и других внести список публикаций из путеводителей. 
       Сейчас поиск по ним ничего не дает.
       Надо повышать эффективность хранилищ таким образом. 
    - некоторые файлы пдф в хранилищах повреждены и не читаются.
       У меня есть код для извлечения свойств пдф, он выявляет нечитаемые файлы. 
       Но его нельзя встроить в движок - он реализован в отдельной Длл. Только в приложениях можно использовать.
       Так вот, надо для всех файлов пдф во всех хранилищах:
       - извлечь тексты для поля описания файла - собрать все в одну строку и в Карточку Документа добавить.
       - если файл не читается, открыть его вручную или удалить из хранилища. 
         - переделать использующие их записи сущностей - удалить из них ид записи файла.
         - удалить саму запись файла. 
         - удалить файл из архива Хранилища.
         - Для этой работы предполагалась функция оптимизации Хранилища.
       - Это сейчас сделать нельзя - нет функций записи изменений в карточку Сущности и карточку Файла.  
          
      
- в Движке:
  + переделал функцию public List<string> Manager.GetEntityCategoryNames() 
   на возврат полных путей классов, используя БазовыйКлассХранилища.
  + переделал получение БазовыйКлассХранилища - теперь из поля StorageType свойств Хранилища.
  + переделал функцию получения свойств хранилища из БД 
   internal string DbAdapter.getStorageInfoValue(string keyname)
   на более универсальную - задавая название параметра. 
  + добавил старые классы дерева классов в пространство имен ClassificationEntity.oldversion
    Это неправильно - тащить в проект всякий хлам, но он потом должен пригодиться 
    при разработке лучшей системы классов. Поэтому пускай пока лежит тут.
  + перенес сюда public static bool Manager.IsStorageFolder(string path) из браузера.  
- В браузере Хранилищ: 
  + переделал загрузку классов из хранилищ на новый способ с полными путями классов
  + сделал пункт меню выгрузить дерево классов, написал код, тестировал.
    - дерево классов хранится глобально в StorageSearcher.m_storageClasses
    + переделал код теперь используется этот список.
    - но я собираюсь его сделать временным, а пользоваться только деревом классов.
      Хотя списком будет и правда проще выводить в файл, если его сортировать.
      Но я уже написал код по дереву, его можно впрочем удалить, чтобы упростить проект.
    - я хотел сделать список классов отдельным объектом и словарем, 
       тогда в него можно будет вставить эту функцию, раз она потребовалась.  

- надо сделать еще работы:
  - надо допилить приложение и движок до удовлетворительного состояния для работы с моими хранилищами.
  - надо провести новый тест, описать все работы что еще не закончены и предполагаются - для 
     восстановления контекста работы после перерыва.
  - в браузере и в движке есть обозначенные, но не реализованные функции.
  - надо сделать код для процесса создания хранилища, с формами и проверкой данных, особенно формата классов итп.    
  - еще работы описаны тут в тексте выше. Надо осмотреть и определить их полезность.
  - следующим витком проекта будет, видимо, создание новой классификации 
     и переделка всех хранилищ на эту новую классификацию.
    - надо написать конвертер из бд в ксв-файл и обратно. 
       Создать ксв, редактировать классы, вписать обратно автоматически.
       Вручную я это все за месяц не сделаю, а конвертером - за неделю.

21 октября 2017
- проект приостанавливается, так как первичная цель достигнута, и нужно переключиться на другие проекты.
  - в проекте много мусора и много тодо-меток. Но наводить в них порядок мне некогда сейчас.
- надо написать документацию по этим классам и их работе в Хранилище. 
   Иначе потом я не смогу всю систему Хранилищ запустить, когда забуду про эти классы и их условия.
   Сейчас я их помню, и вроде все гладко. А потом я забуду и не смогу быстро разобраться, почему Хранилище недоступно.
   А документация у меня сейчас устаревшая и во многом неправильная.
   
26 октября 2017
- обнаружил ошибку: если несколько сущностей подряд используют один и тот же файл, то только первая запись имеет этот файл, остальные нет.
  - оказалось, ИД записи файла записывается после того как файл добавляется в пакетный буфер, 
     а в пакетный буфер записывается копия объекта, поэтому туда не передается ИД файла в таблице.
     Поэтому при поиске дубликата файла для следующей записи сущности, дубликат находится, но у него нет ИД записи таблицы (= 0).
     Так запись сущности и пишется в БД, и получается, что у нее нет прикрепленного файла.
     Пришлось передавать из функции internal string ArchiveController.addFileBuffered(..) 
     наружу этот объект записи файла и в него записывать ИД файла в таблице.
  - исправил, протестировал, теперь все правильно делается.
  - Надо все же перепроектировать код в этой части, чтобы все было лаконично и аккуратно, а то это сопля такая получилась.
- обнаружил ошибку - Исключение выбрасывается Файл уже существует. 
  - стек трейс:    at System.IO.__Error.WinIOError(Int32 errorCode, String maybeFullPath)
   at System.IO.File.InternalCopy(String sourceFileName, String destFileName, Boolean overwrite)
   at System.IO.File.Copy(String sourceFileName, String destFileName)
   at InventoryModuleManager2.Session.StoreBulkBufferedFile(String filepath, String fileArchName) in C:\Work\myVirtualDisk\МоиПроекты\УтилитыХранилищ\РаботатьЗдесь\InventoryModuleManager2\InventoryModuleManager2\Session.cs:line 171
   at InventoryModuleManager2.ArchiveController.addFileBuffered(String fileArchName, FileRecord fr, FileRecord& copyFr) in C:\Work\myVirtualDisk\МоиПроекты\УтилитыХранилищ\РаботатьЗдесь\InventoryModuleManager2\InventoryModuleManager2\ArchiveController.cs:line 367
   at InventoryModuleManager2.Manager.addDocumentBuffered(EntityRecord entity) in C:\Work\myVirtualDisk\МоиПроекты\УтилитыХранилищ\РаботатьЗдесь\InventoryModuleManager2\InventoryModuleManager2\Manager.cs:line 927
   at InventoryModuleManager2.Manager.AddEntityBuffered(EntityRecord entity) in C:\Work\myVirtualDisk\МоиПроекты\УтилитыХранилищ\РаботатьЗдесь\InventoryModuleManager2\InventoryModuleManager2\Manager.cs:line 840                                       
  - это надо исправить, но сейчас я не могу - устал.
  - предположительно, это потому что имена файлов берутся от архивных, а в них они обрабатываются: удаляются пробелы и левые символы.
   Так, файлы file.ext и fi le.ext получают одинаковые (без учета регистра) имена, что и проводит к исключению. 
   Но почему не даются им уникальные имена - я не знаю пока. Наверно, надо сравнивать их без учета регистра.
  - такая же ошибка 18112018: файлы  Жизнь растений т5ч1 Цветковые растения.djvu и  Жизнь растений т5ч2 Цветковые растения.djvu 
     приводят к ошибке "Файл уже существует" в функции public void Manager.AddEntityBuffered(EntityRecord entity)  
     при этом путь файла в временном каталоге для пакета обрезан до "Жизнь растений т5ч" (пробелов наверно нет, не помню)
     и оба файла поэтому получаются с одинаковыми именами, это и дает ошибку.
  - сообщение: The file 'C:\Documents and Settings\John Smith\Local Settings\Temp\zgtyeiqh.nqv\Bulk\ИльинВАМатематич.djvu' already exists.   
- вторая ошибка ловится на том же месте: Сообщение что такой ключ уже существует.
  Возникает, когда документ и картинка имеют одинаковое имя и разное расширение.
- исправил ошибку, при которой нельзя было создать Хранилище.
  Строка класса Хранилища читалась из БД, но при создании Хранилища она еще пустая.
  А чтобы ее записать в БД Хранилища, его надо сначала открыть.
  Поэтому я создал отдельную функцию для такого случая.
  Теперь все создается и работает вроде бы нормально.  
  - Версию Движка изменил на 1.1.3.0 из-за этого исправления.  
- Для воспроизведения ошибок моожно использовать книги Фантастика из моей коллекции книг.
  Я когда их помещал в Хранилища, папка Фантастика воспроизвела все эти ошибки движка.

25 декабря 2018
- Нашел еще ошибку - в функции private static bool Manager.isReadOnly(String storageRootFolder)  
   Исправил функцию, ошибка была редкой. Но теперь надо бы изменить версию и перевыпустить все.
   - а не буду. Исправлю существенные ошибки, тогда заменю версию и перевыпущу все программы.
     Сейчас их заменять на конечном устройстве - лень. А на работу эта переделка не влияет.
- Надо бы завести класс DocumentConverterUtility и в него запихать все эти мои функции конвертеров,
   которые я использую. Все равно библиотека используется для Хранилища, так и эти функции поместить туда, чтобы клиента упростить.    